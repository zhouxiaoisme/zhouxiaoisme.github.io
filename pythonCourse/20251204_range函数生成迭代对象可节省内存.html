<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>序列 vs 可迭代对象 | Python 可视化讲解</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: "微软雅黑", Arial, sans-serif;
        }
        body {
            padding: 2rem;
            line-height: 1.8;
            background-color: #f5f7fa;
        }
        .container {
            max-width: 1000px;
            margin: 0 auto;
            background: white;
            padding: 2rem;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #2c3e50;
            text-align: center;
            margin-bottom: 2rem;
            border-bottom: 3px solid #3498db;
            padding-bottom: 1rem;
        }
        h2 {
            color: #3498db;
            margin: 1.5rem 0 1rem;
        }
        h3 {
            color: #2980b9;
            margin: 1rem 0 0.8rem;
        }
        .comparison {
            display: flex;
            gap: 2rem;
            margin: 2rem 0;
            flex-wrap: wrap;
        }
        .card {
            flex: 1;
            min-width: 300px;
            border: 2px solid #ddd;
            border-radius: 8px;
            padding: 1.5rem;
            transition: all 0.3s;
        }
        .card:hover {
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        .card.sequence {
            border-color: #e74c3c;
        }
        .card.iterable {
            border-color: #2ecc71;
        }
        .card h3 {
            text-align: center;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid currentColor;
        }
        .memory-visual {
            margin: 1rem 0;
            border: 1px solid #ddd;
            padding: 1rem;
            border-radius: 4px;
            background: #f9f9f9;
        }
        .memory-block {
            display: inline-block;
            padding: 0.5rem 1rem;
            margin: 0.3rem;
            border-radius: 4px;
            color: white;
        }
        .sequence-block {
            background: #e74c3c;
        }
        .iterable-meta {
            background: #2ecc71;
        }
        .iterable-generate {
            background: #f39c12;
            opacity: 0.5;
        }
        .code-block {
            background: #2c3e50;
            color: white;
            padding: 1rem;
            border-radius: 6px;
            margin: 1rem 0;
            overflow-x: auto;
            font-family: "Consolas", monospace;
        }
        .highlight {
            background: #f1c40f;
            padding: 0 0.3rem;
            border-radius: 3px;
            font-weight: bold;
        }
        .scenario {
            background: #f8f9fa;
            border-left: 4px solid #3498db;
            padding: 1rem 1.5rem;
            margin: 1.5rem 0;
        }
        .btn {
            padding: 0.8rem 1.5rem;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1rem;
            margin: 1rem 0;
        }
        .btn:hover {
            background: #2980b9;
        }
        #demo-result {
            margin-top: 1rem;
            padding: 1rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            min-height: 50px;
        }
        .advantage-list {
            list-style: none;
            margin: 1rem 0;
        }
        .advantage-list li {
            padding: 0.8rem;
            margin: 0.5rem 0;
            background: #f1f9ff;
            border-left: 4px solid #3498db;
            border-radius: 0 4px 4px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>序列 vs 可迭代对象：区别与优势</h1>

        <h2>一、核心概念</h2>
        <p><strong>序列（如列表）</strong>：一次性生成所有元素，全部存入内存，可直接访问任意元素。</p>
        <p><strong>可迭代对象（如range）</strong>：仅存储「生成规则」（起始/结束/步长），迭代时才逐个生成元素，不提前占用内存。</p>

        <h2>二、可视化对比（以 range(0,10,2) 为例）</h2>
        <div class="comparison">
            <!-- 序列卡片 -->
            <div class="card sequence">
                <h3 style="color: #e74c3c;">直接生成序列（列表）</h3>
                <div class="code-block">
lst = list(range(0,10,2))<br>
# 结果：[0, 2, 4, 6, 8]
                </div>
                <h4>内存可视化：</h4>
                <div class="memory-visual">
                    <p>内存中直接存储所有元素：</p>
                    <span class="memory-block sequence-block">0</span>
                    <span class="memory-block sequence-block">2</span>
                    <span class="memory-block sequence-block">4</span>
                    <span class="memory-block sequence-block">6</span>
                    <span class="memory-block sequence-block">8</span>
                </div>
                <h4>特点：</h4>
                <ul>
                    <li>立即占用所有元素的内存</li>
                    <li>可直接通过索引访问（如 lst[3] → 6）</li>
                    <li>生成后元素固定不变</li>
                </ul>
            </div>

            <!-- 可迭代对象卡片 -->
            <div class="card iterable">
                <h3 style="color: #2ecc71;">生成可迭代对象（range）</h3>
                <div class="code-block">
r = range(0,10,2)<br>
# 结果：range(0, 10, 2)
                </div>
                <h4>内存可视化：</h4>
                <div class="memory-visual">
                    <p>内存中仅存储规则（元数据）：</p>
                    <span class="memory-block iterable-meta">起始:0</span>
                    <span class="memory-block iterable-meta">结束:10</span>
                    <span class="memory-block iterable-meta">步长:2</span>
                    <p style="margin-top: 0.5rem;">迭代时才生成元素（按需生成）：</p>
                    <span class="memory-block iterable-generate">0（迭代时生成）</span>
                    <span class="memory-block iterable-generate">2（迭代时生成）</span>
                    <span class="memory-block iterable-generate">4（迭代时生成）</span>
                    <span class="memory-block iterable-generate">6（迭代时生成）</span>
                    <span class="memory-block iterable-generate">8（迭代时生成）</span>
                </div>
                <h4>特点：</h4>
                <ul>
                    <li>几乎不占用内存（仅存3个数字）</li>
                    <li>无法直接索引（需迭代/转换后访问）</li>
                    <li>元素按需生成，节省资源</li>
                </ul>
            </div>
        </div>

        <h2>三、场景化实例：百万级数据处理</h2>
        <div class="scenario">
            <h3>场景：需要遍历 0 到 100万 的所有偶数</h3>
            <div class="comparison">
                <div class="card sequence">
                    <h3 style="color: #e74c3c;">方案1：生成列表（序列）</h3>
                    <div class="code-block">
# 生成包含50万个元素的列表<br>
big_list = list(range(0, 1000000, 2))<br>
for num in big_list:<br>
    pass  # 假设做简单计算
                    </div>
                    <p class="highlight">问题：</p>
                    <p>50万个整数会占用约 <strong>4MB</strong> 内存（仅示例），若数据量到1亿，内存会直接溢出！</p>
                </div>
                <div class="card iterable">
                    <h3 style="color: #2ecc71;">方案2：使用range（可迭代对象）</h3>
                    <div class="code-block">
# 仅存储规则，不生成元素<br>
big_range = range(0, 1000000, 2)<br>
for num in big_range:<br>
    pass  # 迭代时逐个生成元素
                    </div>
                    <p class="highlight">优势：</p>
                    <p>无论数据量多大，仅占用 <strong>几十字节</strong> 内存（存储起始/结束/步长），永远不会内存溢出！</p>
                </div>
            </div>
        </div>

        <h2>四、交互演示：内存占用对比</h2>
        <a href="./20251204_生成1亿偶数列表的内存崩溃问题和range可迭代对象的轻量优势对比.html">交互演示</a>
        

        <h2>五、可迭代对象的核心好处</h2>
        <ul class="advantage-list">
            <li><strong>极致省内存</strong>：处理超大范围数据时，不会因内存不足崩溃（如 range(10亿) 依然流畅）。</li>
            <li><strong>按需生成</strong>：迭代到某个元素时才生成，避免提前生成用不到的元素（如循环中途break，不会浪费资源）。</li>
            <li><strong>轻量级</strong>：创建速度极快（仅存规则，不生成元素），而生成大列表需要大量时间和内存。</li>
            <li><strong>无限迭代</strong>：可实现「无限可迭代对象」（如生成无限数列），而序列无法存储无限元素。</li>
        </ul>

        <h2>六、总结：什么时候用？</h2>
        <ul>
            <li>需要频繁随机访问元素 → 用序列（列表/元组）；</li>
            <li>仅需遍历一次、数据量较大 → 用可迭代对象（range/生成器）；</li>
            <li>追求内存效率、避免资源浪费 → 优先用可迭代对象。</li>
        </ul>
    </div>

    <script>
        // 模拟内存占用演示
        function showMemoryDemo() {
            const result = document.getElementById('demo-result');
            result.innerHTML = `
                <div style="color: #e74c3c; font-weight: bold;">生成列表（1亿偶数）：</div>
                <p>尝试生成 list(range(0, 100000000, 2)) → 浏览器/解释器会卡顿，甚至崩溃（内存不足）</p>
                <div style="color: #2ecc71; font-weight: bold; margin-top: 1rem;">使用range（1亿偶数）：</div>
                <p>生成 range(0, 100000000, 2) → 瞬间完成，内存占用仅几十字节（如下截图）：</p>
                <img src="https://via.placeholder.com/600x100?text=range(0,100000000,2)+%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8：0.0001MB" style="max-width: 100%; margin-top: 0.5rem;" alt="内存占用对比">
            `;
        }
    </script>
</body>
</html>